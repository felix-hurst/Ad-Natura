\documentclass[12pt, titlepage]{article}

\usepackage{fullpage}
\usepackage[numbers]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Guide for \progname{}} 
\author{\authname}
\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov 13 & 1.0 & Initial doc\\
\bottomrule
\end{tabularx}

\newpage

\section{Reference Material}


\subsection{Abbreviations and Acronyms}

AC Anticipated Change \\
DAG Directed Acyclic Graph \\
M Module \\
MG Module Guide \\
OS Operating System \\
R Requirement \\
SC Scientific Computing \\
SRS Software Requirements Specification ProgName Explanation of program name \\
UC Unlikely Change \\


\newpage

\tableofcontents

\listoftables


\newpage

\pagenumbering{arabic}

\section{Introduction}

Decomposing a system into modules is a commonly accepted approach to developing
software.  A module is a work assignment for a programmer or programming
team~\cite{Parnas1984}.  We advocate a decomposition
based on the principle of information hiding~\cite{Parnas1972}.  This
principle supports design for change, because the ``secrets'' that each module
hides represent likely future changes.  Design for change is valuable in SC,
where modifications are frequent, especially during initial development as the
solution space is explored.  

Our design follows the rules layed out by \cite{Parnas1984}, as follows:
\begin{itemize}
\item System details that are likely to change independently should be the
  secrets of separate modules.
\item Each data structure is implemented in only one module.
\item Any other program that requires information stored in a module's data
  structures must obtain it by calling access programs belonging to that module.
\end{itemize}

After completing the first stage of the design, the Software Requirements
Specification (SRS), the Module Guide (MG) is developed~\cite{Parnas1984}. The MG
specifies the modular structure of the system and is intended to allow both
designers and maintainers to easily identify the parts of the software.  The
potential readers of this document are as follows:

\begin{itemize}
\item New project members: This document can be a guide for a new project member
  to easily understand the overall structure and quickly find the
  relevant modules they are searching for.
\item Maintainers: The hierarchical structure of the module guide improves the
  maintainers' understanding when they need to make changes to the system. It is
  important for a maintainer to update the relevant sections of the document
  after changes have been made.
\item Designers: Once the module guide has been written, it can be used to
  check for consistency, feasibility, and flexibility. Designers can verify the
  system in various ways, such as consistency among modules, feasibility of the
  decomposition, and flexibility of the design.
\end{itemize}

The rest of the document is organized as follows. Section
\ref{SecChange} lists the anticipated and unlikely changes of the software
requirements. Section \ref{SecMH} summarizes the module decomposition that
was constructed according to the likely changes. Section \ref{SecConnection}
specifies the connections between the software requirements and the
modules. Section \ref{SecMD} gives a detailed description of the
modules. Section \ref{SecTM} includes two traceability matrices. One checks
the completeness of the design against the requirements provided in the SRS. The
other shows the relation between anticipated changes and the modules. Section
\ref{SecUse} describes the use relation between modules.

\section{Anticipated and Unlikely Changes} \label{SecChange}

This section lists possible changes to the system. According to the likeliness
of the change, the possible changes are classified into two
categories. Anticipated changes are listed in Section \ref{SecAchange}, and
unlikely changes are listed in Section \ref{SecUchange}.

\subsection{Anticipated Changes} \label{SecAchange}

Anticipated changes are the source of the information that is to be hidden
inside the modules. Ideally, changing one of the anticipated changes will only
require changing the one module that hides the associated decision. The approach
adapted here is called design for
change.

\begin{description}
\item[\refstepcounter{acnum} \actheacnum\label{AC1}:] Hardware that the game is made available in (Windows, Mac, Linux, Android, iOS, etc.).
\item[\refstepcounter{acnum} \actheacnum\label{AC2}:] Input device being used (mouse and keyboard, touchscreen, etc.).
\item[\refstepcounter{acnum} \actheacnum\label{AC3}:] Rendering resolution and pixel density for different display types.
\item[\refstepcounter{acnum} \actheacnum\label{AC4}:] Material properties for different destructible objects (softness, strength, friction, texture patterns, etc.).
\item[\refstepcounter{acnum} \actheacnum\label{AC5}:] Number, size, shape and behaviour of debris objects generated from cuts in destructible objects.
\item[\refstepcounter{acnum} \actheacnum\label{AC6}:] Pixel size used for pixelated cut edge rendering.
\item[\refstepcounter{acnum} \actheacnum\label{AC7}:] Algorithm used for irregular edge generation when destroying objects.
\item[\refstepcounter{acnum} \actheacnum\label{AC8}:] Debug and production visualization style of the cutting line and intersection points (colors, sizes, styles).
\item[\refstepcounter{acnum} \actheacnum\label{AC9}:] The physics properties of the environment (i.e. intensity of gravity).
\item[\refstepcounter{acnum} \actheacnum\label{AC10}:] Methodology for cut object selection (top, bottom, closest to player).
\item[\refstepcounter{acnum} \actheacnum\label{AC11}:] Mesh triangulation algorithm (Bresenhan algorithm versus alternatives).
\item[\refstepcounter{acnum} \actheacnum\label{AC12}:] Format and storage location of cut profile configuration data (JSON, databases, etc.).
\item[\refstepcounter{acnum} \actheacnum\label{AC13}:] Force range and patterns for destructible environment.
\item[\refstepcounter{acnum} \actheacnum\label{AC14}:] The lifetime and cleanup behaviour of debris fragments after spawning from destroyed objects.
\item[\refstepcounter{acnum} \actheacnum\label{AC15}:] The collision detection layers and filtering rules/parameters for raycasting.
\item[\refstepcounter{acnum} \actheacnum\label{AC16}:] The availability of accessibility modes, such as contrast adjustments for colorblindness.
\end{description}


\subsection{Unlikely Changes} \label{SecUchange}

The module design should be as general as possible. However, a general system is
more complex. Sometimes this complexity is not necessary. Fixing some design
decisions at the system architecture stage can simplify the software design. If
these decision should later need to be changed, then many parts of the design
will potentially need to be modified. Hence, it is not intended that these
decisions will be changed.

\begin{description}
\item[\refstepcounter{ucnum} \uctheucnum\label{UC1}:] Game engine (Unity).
\item[\refstepcounter{ucnum} \uctheucnum\label{UC2}:] Dimensionality (2D).
\item[\refstepcounter{ucnum} \uctheucnum\label{UC3}:] Focus and use of physics simulation for object behaviour and world simulation.
\item[\refstepcounter{ucnum} \uctheucnum\label{UC4}:] Requirement for real-time object destruction physics.
\item[\refstepcounter{ucnum} \uctheucnum\label{UC5}:] The fundamental geometric representation of objects as pixel-based polygons.
\item[\refstepcounter{ucnum} \uctheucnum\label{UC6}:] Use of entry and exit points as a basis of destructive tools.
\item[\refstepcounter{ucnum} \uctheucnum\label{UC7}:] The partitioning of objects into two entities (original object, cut off object) per tool use.
\item[\refstepcounter{ucnum} \uctheucnum\label{UC8}:] The coordinate system (right-handed 2D cartesian coordinates).
\item[\refstepcounter{ucnum} \uctheucnum\label{UC9}:] Use of mesh rendering techniques for displaying cut objects.
\end{description}

\section{Module Hierarchy} \label{SecMH}

This section provides an overview of the module design. Modules are summarized
in a hierarchy decomposed by secrets in Table \ref{TblMH}. The modules listed
below, which are leaves in the hierarchy tree, are the modules that will
actually be implemented.


\begin{table}[H]
\centering
\begin{tabular}{|p{0.3\textwidth}| p{0.6\textwidth}|}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule
Hardware-Hiding & Unity Input System\\
\midrule
 & Unity Physics 2D\\
\midrule
& Unity Rendering\\
\midrule
& Unity collider system\\
\midrule
Behaviour-Hiding & Player Control module\\
\midrule
& Raycast visualization module\\
\midrule
& Cut execution module\\
\midrule
& Debris generation module\\
\midrule
Cut profile manager module\\
\midrule
Software Decision & Geometric operations module\\
\midrule
& Polygon partitioning module\\
\midrule
& Mesh generation module\\
\midrule
& Pixelation module\\
\midrule
& Physics update module\\
\midrule
& Material properties module\\

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\section{Connection Between Requirements and Design} \label{SecConnection}

The design of the system is intended to satisfy the requirements developed in the SRS. In this stage, the system is decomposed into modules. The connection between requirements and modules is listed in Table 2.\\

\textbf{Design Decisions}\\

The following design decisions are made to bridge the gap between requirements and implementation:\\

\textbf{DD1: Dual Representation} - All cut objects have a pixelated mesh texture using Bresenham algorithm applied to them in contrast with the smooth collision mesh even if the cut was irregular and/or diagonal in order to ensure adherence to the visual style(R6).\\

\textbf{DD2: Material Profile System} - In order to meet the requirement for different cutting behavior on different materials (R5) a JSON-based configuration system maps material names/tags to extendable cutting parameters (softness and strength).\\

\textbf{DD3: Modular Cutting Pipeline} - Cutting object flow can be broken into the following key phases of visualization, partitioning, mesh generation, and debris spawning thereby allowing each phase to be optimized independently and meeting the requirement for real-time interactive cutting (R3) in an extendable and maintainable way.\\

\textbf{DD4: Entry-Exit Point Model} - In order for players to have a clear understanding of what the tool destroys (R2), cuts are defined by exactly two intersection points for each object (entry and exit) which simplifies the logic and provides clear visualization and working feedback to the player\\

\textbf{DD5: Area-Proportional Mass} - For realistic physics behavior after cutting (R4), object mass is updated proportionally to the change in area, maintaining consistent density. \\


\section{Module Decomposition} \label{SecMD}

Modules are decomposed according to the principle of “information hiding” proposed by Parnas et al. (1984). The Secrets field in a module decomposition is a brief statement of the design decision hidden by the module. The Services field specifies what the module will do without documenting how to do it. For each module, a suggestion for the implementing software is given under the Implemented By title. If the entry is OS, this means that the module is provided by the operating system or by standard programming language libraries. ProgName means the module will be implemented by the ProgName software. \\

Only the leaf modules in the hierarchy have to be implemented. If a dash (-) is shown, this means that the module is not a leaf and will not have to be implemented. 


\subsection{Hardware Hiding Modules}

\subsubsection{Unity Input System (M1)} \label{M1}

\paragraph{Secrets}
The data structure and algorithm used to detect and process user input events (mouse position, button presses, keyboard input).

\paragraph{State Variables}
\begin{itemize}
\item $mousePosition : \mathbb{R}^2$ --- Current mouse position in screen coordinates
\item $mouseButtonDown : \mathbb{B}$ --- Whether left mouse button is pressed
\item $keyboardInput : \text{seq of char}$ --- Currently pressed keyboard keys
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
\item Physical mouse device
\item Physical keyboard device
\item Screen resolution and DPI
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{4cm}p{3cm}p{3cm}p{4cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
GetMousePosition & - & Vector2 & - \\
GetMouseButton & int & $\mathbb{B}$ & - \\
GetKey & KeyCode & $\mathbb{B}$ & - \\
ScreenToWorldPoint & Vector2 & Vector2 & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Detects mouse movement and clicks for aiming and tool use, detects keyboard input for player movement and jumping and translates screen coordinates to world coordinates.

\paragraph{Implemented By}
Unity (UnityEngine.InputSystem)

\paragraph{Type of Module}
Library

\subsubsection{Unity Physics2D (M2)} \label{M2}

\paragraph{Secrets}
Library used for rigid bodies, physics, and collisions.

\paragraph{State Variables}
\begin{itemize}
\item $gravity : \mathbb{R}^2$ --- Global gravity vector
\item $physicsTimeStep : \mathbb{R}^+$ --- Fixed time step for physics updates
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
\item System time
\item CPU processing capabilities
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{4cm}p{4cm}p{2cm}p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
Raycast & Vector2, Vector2, $\mathbb{R}$, LayerMask & RaycastHit2D & - \\
AddForce & Rigidbody2D, Vector2 & - & - \\
OverlapPoint & Vector2 & Collider2D & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Performs 2D raycasting with filtering, manages Rigidbody2D components, detects collisions between 2D colliders, applies forces and velocities to objects, simulates gravity and momentum.

\paragraph{Implemented By}
Unity (UnityEngine.Physics2D)

\paragraph{Type of Module}
Library

\subsubsection{Unity Rendering (M3)} \label{M3}

\paragraph{Secrets}
The algorithm for rendering 2D sprites, meshes, and line renderers to the screen with proper depth sorting.

\paragraph{State Variables}
\begin{itemize}
\item $renderQueue : \text{seq of RenderObject}$ --- Queue of objects to render
\item $sortingLayers : \text{seq of Layer}$ --- Defined sorting layers
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
\item Graphics card capabilities
\item Display output device
\item Screen resolution
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{4cm}p{3cm}p{2cm}p{4cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
DrawMesh & Mesh, Material & - & - \\
DrawSprite & Sprite, Vector2 & - & - \\
DrawLine & Vector2, Vector2, Color & - & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Renders sprites, renders dynamically generated meshes with textures, renders LineRenderer components for visualization, manages render order and sorting layers, applies materials and shaders.

\paragraph{Implemented By}
Unity (UnityEngine.Rendering, UnityEngine.SpriteRenderer, UnityEngine.LineRenderer)

\paragraph{Type of Module}
Library

\subsubsection{Unity Collider System (M4)} \label{M4}

\paragraph{Secrets}
The data structure and algorithm for storing and querying 2D collider shapes, including dynamic collider modification.

\paragraph{State Variables}
\begin{itemize}
\item $colliders : \text{seq of Collider2D}$ --- All active colliders in scene
\item $collisionMatrix : \text{LayerMask} \times \text{LayerMask} \rightarrow \mathbb{B}$ --- Layer collision matrix
\end{itemize}

\paragraph{Environment Variables}
None

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{5cm}p{3cm}p{2cm}p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
CreatePolygonCollider & seq of Vector2 & PolygonCollider2D & - \\
UpdateColliderPoints & PolygonCollider2D, seq of Vector2 & - & - \\
GetColliderBounds & Collider2D & Bounds & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Provides BoxCollider2D and PolygonCollider2D components also used to update collider shapes dynamically at runtime for objects and manages collider events.

\paragraph{Implemented By}
Unity (UnityEngine.Collider2D, UnityEngine.PolygonCollider2D, UnityEngine.BoxCollider2D)

\paragraph{Type of Module}
Library

\subsection{Behaviour-Hiding Modules}

\subsubsection*{Secrets}
The contents of the required behaviours.

\subsubsection*{Services}
Includes programs that provide externally visible behaviour of the system as specified in the software requirements specification (SRS) documents. This module serves as a communication layer between the hardware-hiding module and the software decision module. The programs in this module will need to change if there are changes in the SRS.

\subsubsection*{Implemented By}
--

\subsubsection{Player Controller (M5)} \label{M5}

\paragraph{Secrets}
Controls behaviour of the player character such as movement speed, jump height, ground detection, etc.

\paragraph{State Variables}
\begin{itemize}
\item $playerPosition : \mathbb{R}^2$ --- Current position of player
\item $playerVelocity : \mathbb{R}^2$ --- Current velocity vector
\item $isGrounded : \mathbb{B}$ --- Whether player is touching ground
\item $moveSpeed : \mathbb{R}^+$ --- Movement speed in units/second
\item $jumpForce : \mathbb{R}^+$ --- Upward force applied when jumping
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
\item User input from M1
\item Physics simulation from M2
\end{itemize}

\paragraph{Exported Constants}
\begin{itemize}
\item $DEFAULT\_MOVE\_SPEED = 5.0$
\item $DEFAULT\_JUMP\_FORCE = 10.0$
\item $GROUND\_CHECK\_RADIUS = 0.2$
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{3cm}p{3cm}p{2cm}p{5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
Move & $\mathbb{R}$ & - & - \\
Jump & - & - & exc := $\neg isGrounded$ \\
UpdateGroundCheck & - & $\mathbb{B}$ & - \\
InitializeRaycast & - & - & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Based on input from Unity's Input system, moves player character based on input, handles jumping when grounded, initializes and manages the raycast cutting system, visualizes ground check radius in editor.

\paragraph{Implemented By}
PlayerController.cs

\paragraph{Type of Module}
Abstract Object

\subsubsection{Raycast Visualization Module (M6)} \label{M6}

\paragraph{Secrets}
How the cutting line and intersection points are visualized to the user, including colors, sizes, and rendering properties.

\paragraph{State Variables}
\begin{itemize}
\item $lineStartPoint : \mathbb{R}^2$ --- Start position of cutting line
\item $lineEndPoint : \mathbb{R}^2$ --- End position of cutting line
\item $entryPoint : \mathbb{R}^2$ --- Entry intersection point
\item $exitPoint : \mathbb{R}^2$ --- Exit intersection point
\item $targetObject : \text{GameObject}$ --- Currently targeted object
\item $lineColor : \text{Color}$ --- Color of visualization line
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
\item Mouse position from M1
\item Raycast results from M2
\item Rendering system from M3
\end{itemize}

\paragraph{Exported Constants}
\begin{itemize}
\item $ENTRY\_POINT\_COLOR = \text{Green}$
\item $EXIT\_POINT\_COLOR = \text{Orange}$
\item $LINE\_WIDTH = 0.05$
\item $POINT\_RADIUS = 0.1$
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{4cm}p{3cm}p{2cm}p{4cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
DrawCuttingLine & Vector2, Vector2 & - & - \\
DrawIntersectionPoints & Vector2, Vector2 & - & - \\
HighlightCutRegion & seq of Vector2 & - & - \\
DetectMouseClick & - & $\mathbb{B}$ & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Draws a line from player to mouse cursor, displays entry point (green dot) and exit point (orange dot) on target object, highlights the portion of object that will be cut off, filters out invalid raycast targets (player, debris), detects mouse clicks to execute cuts.

\paragraph{Implemented By}
Raycast.cs

\paragraph{Type of Module}
Abstract Object

\subsubsection{Tool Raycast (M7)} \label{M7}

\paragraph{Secrets}
Coordinates between controller and reshape and debris systems as the executor and manager of the tool use. Player controller passes tool type and raycast data to this module which then applies the appropriate cut behavior based on material profiles.

\paragraph{State Variables}
\begin{itemize}
\item $currentCutTarget : \text{GameObject}$ --- Object being cut
\item $toolSelected : \texttt{string}$ --- Tool Selected
\item $entryPoint : \mathbb{R}^2$ --- Cut entry point
\item $exitPoint : \mathbb{R}^2$ --- Cut exit point
\item $cutLineDirection : \mathbb{R}^2$ --- Direction of cut
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
\item Visualization state from M6
\item Material profiles from M9
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{4cm}p{4cm}p{2cm}p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
ExecuteCut & GameObject, Vector2, Vector2 & - & exc := $target = null$ \\
ApplyCutBehavior & GameObject, CutProfile & - & - \\
HighlightEdge & seq of Vector2 & - & - \\
SelectCutPortion & GameObject & seq of Vector2 & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Responsible for applying the appropriate cut behavior and edge highlighting and cut selection coordinating between ObjectReshape and DebrisSpawner.

\paragraph{Implemented By}
RaycastReceiver.cs

\paragraph{Type of Module}
Abstract Object

\subsubsection{Debris Generation (M8)} \label{M8}

\paragraph{Secrets}
Generating and distributing debris fragments within the cut-off area, including fragment sizing and positioning.

\paragraph{State Variables}
\begin{itemize}
\item $activeDebris : \text{seq of GameObject}$ --- Currently active debris objects
\item $debrisLifetime : \mathbb{R}^+$ --- Time before debris cleanup
\item $explosionForce : \mathbb{R}^+$ --- Force applied to debris
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
\item Physics system from M2
\item Rendering system from M3
\item Collider system from M4
\end{itemize}

\paragraph{Exported Constants}
\begin{itemize}
\item $DEFAULT\_DEBRIS\_COUNT = 5$
\item $DEFAULT\_LIFETIME = 10.0$
\item $MASS\_MULTIPLIER = 0.1$
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{5cm}p{3cm}p{2cm}p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
SpawnDebris & seq of Vector2, int, Material & seq of GameObject & - \\
PositionFragment & Vector2, seq of Vector2 & Vector2 & - \\
ApplyExplosionForce & GameObject, Vector2, $\mathbb{R}$ & - & - \\
CleanupDebris & GameObject & - & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Creates specified number of debris fragments based on object config and cut size, positions fragments within cut-off polygon using point-in-polygon testing, applies physics properties (mass, velocity, angular velocity) and applies explosion force radiating from cut centroid as well as managing debris lifetime and cleanup.

\paragraph{Implemented By}
DebrisSpawner.cs

\paragraph{Type of Module}
Abstract Object

\subsubsection{Cut Profile Manager (M9)} \label{M9}

\paragraph{Secrets}
Manager cut profiles and retrieval for material specific cutting profiles.

\paragraph{State Variables}
\begin{itemize}
\item $cutProfiles : \text{Tag} \rightarrow \text{CutProfile}$ --- Mapping of tags to profiles
\item $defaultProfile : \text{CutProfile}$ --- Default cutting parameters
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
\item JSON configuration file
\end{itemize}

\paragraph{Exported Constants}
\begin{itemize}
\item $DEFAULT\_SOFTNESS = 0.5$
\item $DEFAULT\_STRENGTH = 0.5$
\item $DEFAULT\_DEBRIS\_COUNT = 5$
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{5cm}p{3cm}p{2cm}p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
LoadProfiles & string & - & exc := invalid JSON \\
GetProfileForObject & GameObject & CutProfile & - \\
ApplyIrregularCut & seq of Vector2, CutProfile & seq of Vector2 & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Loads cut profiles from JSON configuration and applies them based on object tag (otherwise supplies default profile when specific profile not found) and applies irregular cutting based on material properties (softness and strength parameters).

\paragraph{Implemented By}
CutProfileManager.cs

\paragraph{Type of Module}
Abstract Object

\subsection{Software Decision Modules}

\subsubsection*{Secrets}
The design decision based on mathematical theorems, physical facts, or programming considerations. The secrets of this module are not described in the SRS.

\subsubsection*{Services}
Includes data structure and algorithms used in the system that do not provide direct interaction with the user.

\subsubsection*{Implemented By}
--

\subsubsection{Geometric Operations (M10)} \label{M10}

\paragraph{Secrets}
Algorithms for fundamental geometric calculations on 2D shapes including the shoelace formula, cross products, distance calculations.

\paragraph{State Variables}
None (stateless module)

\paragraph{Environment Variables}
None

\paragraph{Exported Constants}
\begin{itemize}
\item $EPSILON = 10^{-6}$ --- Floating point comparison tolerance
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{4cm}p{3cm}p{3cm}p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
CalculateArea & seq of Vector2 & $\mathbb{R}^+$ & - \\
CalculateCentroid & seq of Vector2 & Vector2 & - \\
CrossProduct & Vector2, Vector2 & $\mathbb{R}$ & - \\
Distance & Vector2, Vector2 & $\mathbb{R}^+$ & - \\
Normalize & Vector2 & Vector2 & exc := $\|v\| = 0$ \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Calculates polygon areas for object reshaping after a cut is applied from the raycast for both colliders and mesh renders.

\paragraph{Implemented By}
ObjectReshape.cs (geometric utility functions), PixelatedCutRenderer.cs (grid operations)

\paragraph{Type of Module}
Library

\subsubsection{Polygon Partitioning (M11)} \label{M11}

\paragraph{Secrets}
The algorithm for splitting a polygon into two parts, the original piece and the cutoff piece along a cut line using cross product side determination.

\paragraph{State Variables}
None (stateless module)

\paragraph{Environment Variables}
None

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{5cm}p{4cm}p{2cm}p{2cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
PartitionPolygon & seq of Vector2, Vector2, Vector2 & (seq of Vector2) $\times$ (seq of Vector2) & - \\
DetermineKeepSide & seq of Vector2, seq of Vector2, Vector2 & seq of Vector2 & - \\
AddIntersectionPoints & seq of Vector2, Vector2, Vector2 & seq of Vector2 & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Partitions polygon vertices based on which side of cut line they fall on, adds entry and exit points to both resulting polygons and determines which partition matches highlighted shape using centroid comparison while preserving vertex ordering.

\paragraph{Implemented By}
ObjectReshape.cs (CutOffPortion method)

\paragraph{Type of Module}
Library

\subsubsection{Mesh Generation Module (M12)} \label{M12}

\paragraph{Secrets}
Converting polygon vertices into renderable mesh data using ear clipping triangulation.

\paragraph{State Variables}
None (stateless module)

\paragraph{Environment Variables}
\begin{itemize}
\item Rendering system from M3
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{4cm}p{3cm}p{2cm}p{4cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
TriangulatePolygon & seq of Vector2 & seq of int & exc := $|V| < 3$ \\
GenerateUVs & seq of Vector2 & seq of Vector2 & - \\
CreateMesh & seq of Vector2, seq of int & Mesh & - \\
IsEar & Vector2, Vector2, Vector2, seq of Vector2 & $\mathbb{B}$ & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Implements ear-clipping algorithm to triangulate arbitrary polygons, automatically generates UV coordinates based on the polygon's bounding box, constructs Unity Mesh objects given the vertex data, supports both convex and concave shapes.

\paragraph{Implemented By}
ObjectReshape.cs (UpdateVisualMesh, TriangulatePolygon methods)

\paragraph{Type of Module}
Library

\subsubsection{Pixelation Module (M13)} \label{M13}

\paragraph{Secrets}
For visual uniformity, converting smooth diagonal cut lines into pixel-aligned staircase patterns using a modified Bresenham approach.

\paragraph{State Variables}
None (stateless module)

\paragraph{Environment Variables}
None

\paragraph{Exported Constants}
\begin{itemize}
\item $DEFAULT\_PIXEL\_SIZE = 0.0625$
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{4cm}p{3cm}p{3cm}p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
PixelateCutEdges & seq of Vector2, $\mathbb{R}^+$ & seq of Vector2 & - \\
SnapToGrid & Vector2, $\mathbb{R}^+$ & Vector2 & - \\
IdentifyCutEdges & seq of Vector2, Vector2, Vector2 & seq of (int $\times$ int) & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Pixelates only cut edges while keeping original edges intact, snaps points to a pixel grid with floor-based rounding, creates staircase patterns with horizontal and vertical segments only.

\paragraph{Implemented By}
PixelatedCutRenderer.cs

\paragraph{Type of Module}
Library

\subsubsection{Physics Update Module (M14)} \label{M14}

\paragraph{Secrets}
The algorithm for updating physics properties after shape modification including the area-based mass calculation method.

\paragraph{State Variables}
None (stateless module)

\paragraph{Environment Variables}
\begin{itemize}
\item Physics system from M2
\item Collider system from M4
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{5cm}p{3cm}p{2cm}p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
UpdateCollider & GameObject, seq of Vector2 & - & - \\
UpdateRigidbodyMass & Rigidbody2D, $\mathbb{R}^+$, $\mathbb{R}^+$ & - & - \\
ConvertToPolygonCollider & GameObject & PolygonCollider2D & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Converts from BoxCollider2D to PolygonCollider2D to match new object shape and adjusts proportionally the RigidBody 2D mass to match the new area change using the shoelace area calculation, creates smooth collider for physics and pixelated visual mesh for visual consistency.

\paragraph{Implemented By}
ObjectReshape.cs (UpdateCollider, UpdateRigidbodyMass methods)

\paragraph{Type of Module}
Library

\subsubsection{Material Properties Module (M15)} \label{M15}

\paragraph{Secrets}
The data structure for storing material cutting characteristics and the algorithm for applying irregular edge offsets.

\paragraph{State Variables}
None (stateless module)

\paragraph{Environment Variables}
None

\paragraph{Exported Constants}
\begin{itemize}
\item $MIN\_SEGMENTS = 3$
\item $MAX\_SEGMENTS = 15$
\item $SMOOTH\_THRESHOLD = 0.33$
\item $JAGGED\_THRESHOLD = 0.67$
\end{itemize}

\paragraph{Access Programs}

\begin{center}
\begin{tabular}{p{5cm}p{3cm}p{2cm}p{3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
GenerateIrregularEdge & Vector2, Vector2, $\mathbb{R}$, $\mathbb{R}$ & seq of Vector2 & - \\
CalculateSegmentCount & $\mathbb{R}$ & $\mathbb{N}$ & - \\
CalculateMaxOffset & $\mathbb{R}$, $\mathbb{R}$ & $\mathbb{R}^+$ & - \\
ApplySineWave & Vector2, Vector2, int, $\mathbb{R}$ & seq of Vector2 & - \\
ApplyRandomOffset & Vector2, Vector2, int, $\mathbb{R}$ & seq of Vector2 & - \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Services}
Defines softness parameter ($0 =$ jagged and $1 =$ smooth) which affects segment count, defines strength parameter ($0 =$ clean cut and $1 =$ maximum irregularity) affecting offset magnitude, generates irregular cut edges using different functions based on softness (sine waves for smooth, random for jagged and hybrid for medium).

\paragraph{Implemented By}
CutProfileManager.cs (ApplyIrregularCut, GenerateIrregularEdge methods)

\paragraph{Type of Module}
Library

\section{Traceability Matrix} \label{SecTM}

This section shows two traceability matrices: between the modules and the
requirements and between the modules and the anticipated changes.

% the table should use mref, the requirements should be named, use something
% like fref
\begin{table}[H]
\centering
\caption{Trace Between Requirements and Modules}
\begin{tabular}{|p{0.2\textwidth}| p{0.6\textwidth}|}
\toprule
\textbf{Req.} & \textbf{Modules}\\
\midrule
R1: Player Movement and Control & \mref{M1}, \mref{M2}, \mref{M5}\\
R2: Cutting Line Visualization & \mref{M1}, \mref{M2}, \mref{M3}, \mref{M6}\\
R3: Real-time Object Cutting & \mref{M2}, \mref{M3}, \mref{M4}, \mref{M7}, \mref{M10}, \mref{M11}, \mref{M12}, \mref{M14}\\
R4: Debris Generation & \mref{M2}, \mref{M3}, \mref{M4}, \mref{M8}, \mref{M10}\\
R5: Material Specific Cutting & \mref{M7}, \mref{M9}, \mref{M15}\\
R6: Pixelated Rendering & \mref{M3}, \mref{M10}, \mref{M12}, \mref{M13}\\
R7: Physics Simulation & \mref{M2}, \mref{M4}, \mref{M14}\\
R8: Collision Detection & \mref{M2}, \mref{M4}, \mref{M6}\\
R9: Visual Feedback & \mref{M3}, \mref{M6}, \mref{M7}\\
R10: Multiple Cuts on Same Object & \mref{M7}, \mref{M11}, \mref{M12}, \mref{M14}\\
\bottomrule
\end{tabular}
\caption{Trace Between Requirements and Modules}
\label{TblRT}
\end{table}

\begin{table}[H]
\centering
\caption{Trace between Anticipated Changes and Modules}
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{AC} & \textbf{Modules}\\
\midrule
\acref{AC1} &  \mref{M1},  \mref{M2},  \mref{M3},  \mref{M4}\\
\acref{AC2} &  \mref{M1},  \mref{M5}\\
\acref{AC3} &  \mref{M3}\\
\acref{AC4} &  \mref{M9},  \mref{M15}\\
\acref{AC5} &  \mref{M8}\\
\acref{AC6} &  \mref{M13}\\
\acref{AC7} &  \mref{M15}\\
\acref{AC8} &  \mref{M6}\\
\acref{AC9} &  \mref{M14}\\
\acref{AC10} &  \mref{M7}\\
\acref{AC11} &  \mref{M12}\\
\acref{AC12} &  \mref{M9}\\
\acref{AC13} &  \mref{M8}\\
\acref{AC14} &  \mref{M8}\\
\acref{AC15} &  \mref{M6}\\
\bottomrule
\end{tabular}
\caption{Trace Between Anticipated Changes and Modules}
\label{TblACT}
\end{table}

\section{Use Hierarchy Between Modules} \label{SecUse}

The following list describes the direct dependencies between modules (A $\rightarrow$ B means A uses B):\\

\begin{itemize}
\item \mref{M5} $\rightarrow$ \mref{M1}, \mref{M6}
\item \mref{M6} $\rightarrow$ \mref{M1}, \mref{M2}, \mref{M3}, \mref{M7}, \mref{M10}
\item \mref{M7} $\rightarrow$ \mref{M8}, \mref{M9}, \mref{M10}, \mref{M11}, \mref{M12}, \mref{M13}, \mref{M14}
\item \mref{M8} $\rightarrow$ \mref{M2}, \mref{M3}, \mref{M4}, \mref{M10}
\item \mref{M9} $\rightarrow$ \mref{M15}
\item \mref{M10} $\rightarrow$ \mref{M2}
\item \mref{M11} $\rightarrow$ \mref{M10}
\item \mref{M12} $\rightarrow$ \mref{M3}, \mref{M10}
\item \mref{M13} $\rightarrow$ \mref{M10}
\item \mref{M14} $\rightarrow$ \mref{M2}, \mref{M4}, \mref{M10}
\item \mref{M15} $\rightarrow$ \mref{M10}

\end{itemize}

\subsection{Use Hierarchy levels}

\textbf{Level 0 (Foundation - Hardware Hiding)}\\
\begin{itemize}
\item \mref{M1}
\item \mref{M2}
\item \mref{M3}
\item \mref{M4}
\end{itemize}
\textbf{Level 1 (Utility - Basic Operations)}\\
\begin{itemize}
\item \mref{M10}
\end{itemize}
\textbf{Level 2 (Algorithm - Core computations)}\\
\begin{itemize}
\item \mref{M11}
\item \mref{M12}
\item \mref{M13}
\item \mref{M14}
\item \mref{M15}
\end{itemize}
\textbf{Level 3 (Services - System Coordination)}\\
\begin{itemize}
\item \mref{M8}
\item \mref{M9}
\end{itemize}
\textbf{Level 4 (Coordination - Behaviour Management)}\\
\begin{itemize}
\item \mref{M6}
\item \mref{M7}
\end{itemize}
\textbf{Level 5 (Application - User Interface)}\\
\begin{itemize}
\item \mref{M5}
\end{itemize}


\section{User Interfaces}

\subsection*{Aiming Interface}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/aiming_diagram.PNG}
    \caption{Aiming interface diagram}
\end{figure}

The player's mouse draws a line symbolizing the path the strike will take from the character to the mouse position.
Any objects that will be destroyed by the strike are highlighted with an outline.
The player clicks to strike, which is always bound to the circular button.

\subsection*{Tool Selection Interface}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/tool_selection_diagram.PNG}
    \caption{Tool selection interface diagram}
\end{figure}

The player holds the CTRL key to pause the game and uses the mouse wheel to scroll through the available tools.
When the key is released, the highlighted tool is equipped.
The selected tool displays its damage type (Cut, Explosion, or Excavating).

\section{Design of Communication Protocols}

\subsection{Inter-Module Communication}

The system uses Unity's component-based architecture for module communication:

\paragraph{Event-Based Communication:}
\begin{itemize}
\item \textbf{Input Events:} Unity's Input System generates events for mouse clicks, movement, and jumps
\item \textbf{Collision Events:} Physics2D triggers \texttt{OnCollisionEnter2D} events when debris or cut pieces collide
\item \textbf{Frame Events:} Unity's \texttt{Update()} and \texttt{FixedUpdate()} provide timing for continuous operations
\end{itemize}

\paragraph{Direct Method Calls:}
\begin{itemize}
\item M6 (Raycast Visualization) calls M7 (Cut Execution) via \texttt{ExecuteCut()}
\item M7 calls M11 (Polygon Partitioning) via \texttt{PartitionPolygon()}
\item M7 calls M8 (Debris Generation) via \texttt{SpawnDebris()}
\item M9 (Cut Profile Manager) is accessed via static extension method \texttt{GetCutProfileForObject()}
\end{itemize}

\paragraph{Component References:}
\begin{itemize}
\item Modules get references using \texttt{GetComponent<T>()} for same-GameObject communication
\item Modules use \texttt{FindObjectOfType<T>()} for singleton manager access
\item Parent-child relationships use \texttt{GetComponentInChildren<T>()}
\end{itemize}

\subsection{Data Flow}

\begin{enumerate}
\item \textbf{Input Phase:} M1 $\rightarrow$ M5 $\rightarrow$ M6
\item \textbf{Visualization Phase:} M6 $\rightarrow$ M2 $\rightarrow$ M10 $\rightarrow$ M7
\item \textbf{Execution Phase:} M7 $\rightarrow$ M11 $\rightarrow$ M15 $\rightarrow$ M12 $\rightarrow$ M13 $\rightarrow$ M14 $\rightarrow$ M8
\item \textbf{Physics Phase:} M8 $\rightarrow$ M2 $\rightarrow$ M4
\end{enumerate}

\subsection{State Management}

\begin{itemize}
\item Most modules are stateless (M10, M11, M12, M13, M14, M15)
\item State-holding modules use private fields with controlled access (M6, M7, M8, M9)
\item No global variables - all state is encapsulated in components
\item State persists via Unity's serialization (inspector-editable fields marked with \texttt{[SerializeField]})
\end{itemize}

\section{Timeline}

This section details the development timeline for each module, in organized phases.

\subsection{Development Phases}

\paragraph{Phase 1: Core Cutting System (Completed)}
\begin{itemize}
\item M10: Geometric Operations Module
\item M11: Polygon Partitioning Module
\item M12: Mesh Generation Module
\item M14: Physics Update Module
\end{itemize}

\paragraph{Phase 2: User Interaction (Completed)}
\begin{itemize}
\item M5: Player Control Module
\item M6: Raycast Visualization Module
\item M7: Cut Execution Module
\end{itemize}

\paragraph{Phase 3: Enhanced Features (Completed)}
\begin{itemize}
\item M8: Debris Generation Module
\item M9: Cut Profile Manager Module
\item M15: Material Properties Module
\end{itemize}

\paragraph{Phase 4: Visual Polish (Not Complete)}
\begin{itemize}
\item M13: Pixelation Module
\item Visual feedback refinements
\item Debug visualization tools
\end{itemize}

\section{Notation}

The structure of the Module Guide (MG) for modules follows Hoffman and Strooper (1995), with adaptations for Unity game engine components and 2D geometric operations. The mathematical notation comes from Chapter 3 of Hoffman and Strooper (1995) and standard computational geometry references. For instance, the symbol := is used for assignment statements and conditional rules follow the form $(c_1 \Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n)$.

\subsection{Primitive Data Types}

The following table summarizes the primitive data types used by the Destructible Environment System.

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\
\midrule
character & char & A single symbol or digit \\
integer & $\mathbb{Z}$ & A number without a fractional component in $(-\infty, \infty)$ \\
natural number & $\mathbb{N}$ & A number without a fractional component in $[1, \infty)$ \\
real & $\mathbb{R}$ & Any number in $(-\infty, \infty)$ \\
boolean & $\mathbb{B}$ & A truth value: true or false \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Derived Data Types}

The Destructible Environment System uses several derived data types: sequences, vectors, polygons, and tuples.

\textbf{Sequences} are lists filled with elements of the same data type, denoted as seq of T where T is the element type (ex. seq of Vector2 represents a sequence of 2D points).

\textbf{Vectors} represent 2D points or directions in space:
\begin{itemize}
\item Vector2 := $(x: \mathbb{R}, y: \mathbb{R})$
\end{itemize}

\textbf{Polygons} are sequences of vertices that form closed shapes:
\begin{itemize}
\item Polygon := seq of Vector2
\end{itemize}

\textbf{Tuples} contain a list of values and can be of different types. For example (Vector2, Vector2, $\mathbb{R}$) represents a tuple containing two 2D vectors and a real number.

\textbf{Functions} are defined by the data types of their inputs and outputs. Local functions are described by giving their type signature followed by their specification. For example:
\begin{itemize}
\item distance: Vector2 $\times$ Vector2 $\rightarrow$ $\mathbb{R}$
\end{itemize}

\subsection{Geometric Notation}

The following geometric primitives and operations are used throughout the system:

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Symbol} & \textbf{Type} & \textbf{Description} \\
\midrule
$P_{entry}$ & Vector2 & Entry point where cutting ray intersects object surface \\
$P_{exit}$ & Vector2 & Exit point where cutting ray leaves object surface \\
V & seq of Vector2 & Ordered sequence of vertices defining a polygon \\
C & Vector2 & Centroid (geometric center) of a polygon \\
$\hat{d}$ & Vector2 & Normalized direction vector where $\|\hat{d}\| = 1$ \\
$\hat{n}$ & Vector2 & Unit normal (perpendicular) vector to $\hat{d}$ \\
$\theta(P, C)$ & $\mathbb{R}$ & Angle from centroid C to point P \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Cut Profile Parameters}

Material cutting behavior is defined by the following parameters:

\begin{table}[H]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Parameter} & \textbf{Type} & \textbf{Range} & \textbf{Description} \\
\midrule
$\sigma$ & $\mathbb{R}$ & $[0, 1]$ & Softness coefficient: $0 =$ jagged, $1 =$ smooth \\
$\psi$ & $\mathbb{R}$ & $[0, 1]$ & Strength coefficient: $0 =$ clean cut, $1 =$ max irregularity \\
$n_{seg}$ & $\mathbb{N}$ & $[3, 15]$ & Number of segments along cut edge \\
$\delta_{max}$ & $\mathbb{R}$ & $\mathbb{R}^+$ & Maximum perpendicular offset from cut line \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Physics Parameters}

The following parameters govern the physical behavior of objects and debris:

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Parameter} & \textbf{Type} & \textbf{Description} \\
\midrule
$m$ & $\mathbb{R}^+$ & Mass of an object in kilograms \\
$A$ & $\mathbb{R}^+$ & Area of a polygon in square units \\
$v$ & Vector2 & Linear velocity vector \\
$\omega$ & $\mathbb{R}$ & Angular velocity in degrees per second \\
$F_{exp}$ & $\mathbb{R}^+$ & Explosion force magnitude \\
$\kappa$ & $\mathbb{R}^+$ & Mass multiplier constant for debris fragments \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Operators and Functions}

\subsubsection{Logical Operators}
\begin{itemize}
\item $\land$ : logical AND
\item $\lor$ : logical OR
\item $\neg$ : logical NOT
\item $\Rightarrow$ : implies
\end{itemize}

\subsubsection{Set Operators}
\begin{itemize}
\item $\in$ : element of
\item $\cup$ : union
\item $\cap$ : intersection
\item $\subseteq$ : subset of
\item $|$ : such that (set builder notation)
\end{itemize}

\subsubsection{Geometric Functions}

\textbf{Side(L, P):} Determines which side of line L a point P lies on
\begin{itemize}
\item Type: (Vector2 $\times$ Vector2) $\times$ Vector2 $\rightarrow$ $\mathbb{R}$
\item Returns: positive (right), negative (left), or zero (on line)
\item Definition: $(L_{end}.x - L_{start}.x) \times (P.y - L_{start}.y) - (L_{end}.y - L_{start}.y) \times (P.x - L_{start}.x)$
\end{itemize}

\textbf{Area(V):} Calculates the area of a polygon using the shoelace formula
\begin{itemize}
\item Type: seq of Vector2 $\rightarrow$ $\mathbb{R}^+$
\item Definition: $\frac{1}{2}|\sum_{i=0}^{n-1}(v_i.x \times v_{i+1}.y - v_{i+1}.x \times v_i.y)|$
\end{itemize}

\textbf{Distance$(P_1, P_2)$:} Euclidean distance between two points
\begin{itemize}
\item Type: Vector2 $\times$ Vector2 $\rightarrow$ $\mathbb{R}^+$
\item Definition: $\sqrt{(P_2.x - P_1.x)^2 + (P_2.y - P_1.y)^2}$
\end{itemize}

\textbf{Normalize(v):} Converts vector to unit length
\begin{itemize}
\item Type: Vector2 $\rightarrow$ Vector2
\item Definition: $v/\|v\|$ where $\|v\| = \sqrt{v.x^2 + v.y^2}$
\end{itemize}

\textbf{Lerp(a, b, t):} Linear interpolation between values a and b
\begin{itemize}
\item Type: $\mathbb{R} \times \mathbb{R} \times \mathbb{R} \rightarrow \mathbb{R}$ where $t \in [0, 1]$
\item Definition: $a + (b - a) \times t$
\end{itemize}

\textbf{Sort\_CW(V):} Sorts vertices in clockwise order around their centroid
\begin{itemize}
\item Type: seq of Vector2 $\rightarrow$ seq of Vector2
\item Ordering based on increasing $\theta(v_i, C)$
\end{itemize}

\textbf{Snap$(P, p_{size})$:} Snaps point to nearest grid position
\begin{itemize}
\item Type: Vector2 $\times$ $\mathbb{R}^+ \rightarrow$ Vector2
\item Definition: $(\lfloor P.x/p_{size} + 0.5 \rfloor \times p_{size}, \lfloor P.y/p_{size} + 0.5 \rfloor \times p_{size})$
\end{itemize}

\subsection{Conditional Notation}

Conditional rules in specifications follow the format:

$(c_1 \Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n)$

where $c_i$ represents a condition and $r_i$ represents the corresponding result. The conditions are evaluated in order and the first true condition determines the result.

\subsection{State Variables}

State variables represent the mutable state of system components:
\begin{itemize}
\item $V_{visual}$ : seq of Vector2 - Current visual mesh vertices
\item $V_{collider}$ : seq of Vector2 - Current physics collider vertices
\item highlighted : $\mathbb{B}$ - Whether object is currently highlighted
\item cultivated : $\mathbb{B}$ - Whether a valid cut is currently targeted
\end{itemize}

\subsection{Module Access Constants}

The following constants define access restrictions for module operations:
\begin{itemize}
\item \textbf{exported:} Operation is accessible to external modules
\item \textbf{local:} Operation is only accessible within the module
\item \textbf{read-only:} State can be read but not modified externally
\end{itemize}

\bibliographystyle{plain}
\begin{thebibliography}{9}

\bibitem{Parnas1972}
David L. Parnas.
\textit{On the criteria to be used in decomposing systems into modules}.
Comm. ACM, 15(2):1053--1058, December 1972.

\bibitem{Parnas1978}
David L. Parnas.
\textit{Designing software for ease of extension and contraction}.
In ICSE '78: Proceedings of the 3rd international conference on Software engineering, pages 264--277, Piscataway, NJ, USA, 1978. IEEE Press.

\bibitem{Parnas1984}
D.L. Parnas, P.C. Clement, and D.M. Weiss.
\textit{The modular structure of complex systems}.
In International Conference on Software Engineering, pages 408--419, 1984.

\end{thebibliography}

\end{document}